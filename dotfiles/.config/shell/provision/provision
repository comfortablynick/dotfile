#!/usr/bin/env python3
"""Main provisioning script.

TODO:
    - Make generic build/install function for different types:
        - autogen
        - standard configure/make/make install
        - .deb packages
"""
import argparse
import errno
import logging
import os
import shutil
import stat
import subprocess
import sys
import warnings
from contextlib import contextmanager
from pathlib import Path
from shlex import split
from typing import Generator

from github import Github

# Globals {{{1
logging.basicConfig(
    format="%(levelname)s:%(funcName)s: %(message)s", level=logging.WARNING
)
LOG = logging.getLogger(__name__)
APT_CACHE_UPDATED = False

# Utility Functions {{{1
def run(cmd, encoding="utf-8", *args, **kwargs):
    """Run subprocess command

    A string command will be split into a list for subprocess.run()."""
    if not isinstance(cmd, list):
        cmd = split(cmd)
    return subprocess.run(cmd, *args, **kwargs, encoding=encoding)


def mkdir_p(newdir: str) -> None:
    """Make new directory if it doesn't exist.

    Emulates `mkdir -p`
        - if it already exists, silently complete
        - if regular file in the way, raise an exception
        - if parent directories do not exist, make them as well
        From: Pipenv (http://bit.ly/2SLxRwL)
    """
    if os.path.isdir(newdir):
        LOG.debug("%s already exists", newdir)
        pass
    elif os.path.isfile(newdir):
        raise OSError(
            f"a file with the same name as the desired dir, '{newdir}', already exists."
        )

    else:
        head, tail = os.path.split(newdir)
        if head and not os.path.isdir(head):
            mkdir_p(head)
        if tail:
            # Even though we've checked that the directory doesn't exist above, it might exist
            # now if some other process has created it between now and the time we checked it.
            try:
                os.mkdir(newdir)
            except OSError as exn:
                # If we failed because the directory does exist, that's not a problem -
                # that's what we were trying to do anyway. Only re-raise the exception
                # if we failed for some other reason.
                if exn.errno != errno.EEXIST:
                    raise


def set_write_bit(file_name: str) -> None:
    """Make file writable."""
    if isinstance(file_name, str) and not os.path.exists(file_name):
        return
    os.chmod(file_name, stat.S_IWRITE | stat.S_IWUSR | stat.S_IRUSR)
    return


def rmtree(directory: str, ignore_errors=False):
    """Remove directory and contents."""
    LOG.debug("Removing directory tree %s", directory)
    shutil.rmtree(
        directory, ignore_errors=ignore_errors, onerror=handle_remove_readonly
    )


def handle_remove_readonly(func, path: str, exc) -> None:
    """Error handler for shutil.rmtree.

    Windows source repo folders are read-only by default, so this error handler
    attempts to set them as writeable and then proceed with deletion.
    """
    # Check for read-only attribute
    default_warning_message = (
        "Unable to remove file due to permissions restriction: {!r}"
    )
    # split the initial exception out into its type, exception, and traceback
    exc_type, exc_exception, exc_tb = exc
    if is_readonly_path(path):
        # Apply write permission and call original function
        set_write_bit(path)
        try:
            func(path)
        except (OSError, IOError) as e:
            if e.errno in [errno.EACCES, errno.EPERM]:
                warnings.warn(default_warning_message.format(path), ResourceWarning)
                return

    if exc_exception.errno in [errno.EACCES, errno.EPERM]:
        warnings.warn(default_warning_message.format(path), ResourceWarning)
        return

    raise


def is_readonly_path(file_name: str) -> bool:
    """Check if a provided path exists and is readonly.

    Permissions check is `bool(path.stat & stat.S_IREAD)`
    or `not os.access(path, os.W_OK)`
    """
    if os.path.exists(file_name):
        return bool(os.stat(file_name).st_mode & stat.S_IREAD) or not os.access(
            file_name, os.W_OK
        )

    return False


@contextmanager
def chdir(path: str) -> Generator:
    """Context manager to change working directories.

    Usage:
        `with chdir(/path/to/execute/cmd/in):`
    """
    if not path:
        return
    prev_cwd = Path.cwd().as_posix()
    if isinstance(path, Path):
        path = path.as_posix()
    os.chdir(str(path))
    try:
        yield
    finally:
        os.chdir(prev_cwd)


def run_all(args) -> int:
    """Run all provisioning processes."""
    apt_install(args)
    install_fish(args)
    clone_git_repos(args)
    install_ctags(args)
    github_latest_release(args)
    install_mosh(args)
    install_nnn(args)
    install_tmux(args)
    install_todo(args)
    return 0


# Apt {{{1
def apt_update_cache() -> None:
    """Update apt cache"""
    cmd = "sudo apt update -y"
    LOG.debug("Command: %s", cmd)
    run(cmd)
    global APT_CACHE_UPDATED
    APT_CACHE_UPDATED = True
    return


def apt_install(args, pkgs: list = []) -> int:
    """Update apt cache if necessary and install `pkgs`"""
    # TODO: take cli args and add to pkg list if successful
    if not APT_CACHE_UPDATED:
        LOG.info("Updating apt cache")
        apt_update_cache()
    if not len(pkgs):
        LOG.info("No pkgs supplied; getting apt pkgs from disk")
        pkg_file = "~/.config/shell/provision/apt_package"
        try:
            with open(os.path.expanduser(pkg_file), "r") as f:
                pkgs = f.read().splitlines()
        except FileNotFoundError:
            LOG.warning("apt pkg file not found at %s", pkg_file)
            return 1
    cmd = ["sudo", "apt", "install", "-y", *pkgs]
    LOG.debug("Command: %s", cmd)
    try:
        run(cmd)
    except FileNotFoundError:
        LOG.error("apt does not seem to be installed on this system.")
        return 1
    return 0


# Git {{{1
def git_clone(  # {{{2
    repo: str, dest_path: str = None, args: list = ["--recursive"]
) -> None:
    """Clone git repo to dest path."""
    if not shutil.which("git"):
        LOG.error("Git not installed!")
        return
    if not repo[0:4] in ("git@", "http"):
        # Assume it's my repo
        repo = f"git@github.com:comfortablynick/{repo}.git"
    if dest_path is not None:
        args.append(os.path.expanduser(dest_path))
    cmd = ["git", "clone", repo, *args]
    LOG.debug("Cmd: %s", " ".join(cmd))
    with chdir(os.path.expanduser("~/git")):
        run(cmd)
    return


def github_token() -> str:  # {{{2
    """Retrieve secret access token from disk."""
    file = os.path.expanduser("~/.github_token")
    token = ""
    try:
        with open(file, "r") as f:
            token = f.read()
    except FileNotFoundError:
        LOG.error("GitHub token file not found: %s. Aborting!", file)
        return ""
    else:
        return token.strip("\n")


def clone_git_repos(args) -> None:  # {{{2
    """Clone repos from GitHub."""
    token = github_token()
    LOG.info("GitHub token found: %s", token)
    if token == "":
        return
    g = Github(token)
    for repo in g.get_user().get_repos():
        root_files = [content.name for content in repo.get_contents(".")]
        if ".provision_ignore" not in root_files:
            git_clone(repo.ssh_url)


def git_latest_tag() -> str:  # {{{2
    """Return first tag after reverse sort of available tags."""
    return run("git describe --tags --abbrev=0", capture_output=True).stdout.strip("\n")


def github_latest_release(args) -> int:  # {{{2
    """Get latest release binary.

    Params:
    `repo` GitHub repo name in 'user/repo' format
    """
    token = github_token()
    if token == "":
        LOG.error("No GitHub token found!")
        return 1
    LOG.info("GitHub token found: %s", token)
    g = Github(token)
    r = g.get_repo(args.repo)
    name = r.name

    if shutil.which(name) and not args.force:
        LOG.warning("%s already exists. Skipping install!", name)
        return 1
    rel = r.get_releases()[0]  # latest
    assets = rel.get_assets()
    if assets.totalCount is None:
        LOG.error("Repo '%s' has no assets", args.repo)
        return 1
    print("Choose from the following packages:")
    for ctr, asset in enumerate(assets, 1):
        print(f"{str(ctr)}: {asset.name}")
    while True:
        choice = input("Enter number of choice: ")
        if choice == "":
            LOG.error("User input canceled!")
            return 1
        try:
            file = assets[int(choice) - 1]
        except IndexError:
            LOG.error("Choice '%s' out of range!", str(choice))
            continue
        except ValueError:
            LOG.error("Incorrect value: '%s'. Enter a number in range.", str(choice))
            continue
        else:
            break
    print(f"You chose to download {file.name}")
    dl = run(f"wget {file.browser_download_url}", capture_output=True)
    if dl.returncode != 0:
        LOG.error("Download failed! %s", dl.stderr)
    else:
        print("File downloaded to current folder.")
    return dl.returncode


# Install/build apps {{{1
def install_ctags(args) -> int:  # {{{2
    """Download, build, and install universal ctags.

    Params:
    `force_install` Reinstall if already installed
    """
    if shutil.which("ctags") and not args.force:
        LOG.warning("ctags already exists. Skipping install!")
        return 1
    ctags_tmp = "/tmp/ctags"
    rmtree(ctags_tmp, ignore_errors=True)
    run(f"git clone https://github.com/universal-ctags/ctags.git {ctags_tmp}")

    with chdir(ctags_tmp):
        run("./autogen.sh")
        if run("./configure").returncode == 0:
            LOG.debug("ctags build configured. Running `make`")
            run("make")
        else:
            LOG.error("ctags build configure failed!")
            return 1
        LOG.debug("Installing ctags...")
        run("sudo make install")
    LOG.debug("Cleaning up temp directories...")
    rmtree(ctags_tmp, ignore_errors=True)
    return 0


def install_fish(args) -> int:  # {{{2
    """Download, build, and install fish."""
    if shutil.which("fish") and not args.force:
        LOG.warning("fish already exists. Skipping install!")
        return 1
    pkgs = [
        "build-essential",
        "ncurses-dev",
        "libncurses5-dev",
        "gettext",
        "autoconf",
        "doxygen",
    ]
    apt_install(args, pkgs=pkgs)
    fish_tmp = "/tmp/fish"
    rmtree(fish_tmp, ignore_errors=True)
    run(f"git clone https://github.com/fish-shell/fish-shell.git {fish_tmp}")

    with chdir(fish_tmp):
        run("mkdir build")

        with chdir("./build"):
            run("cmake ..")
            run("make")
            LOG.debug("Installing fish...")
            run("sudo make install")
    LOG.debug("Cleaning up temp directories...")
    rmtree(fish_tmp, ignore_errors=True)
    return 0


def install_tmux(args) -> int:  # {{{2
    """Download, build, and install tmux."""
    if shutil.which("tmux") and not args.force:
        LOG.warning("tmux already exists. Skipping install!")
        return 1
    pkgs = [
        "git",
        "automake",
        "build-essential",
        "pkg-config",
        "libevent-dev",
        "libncurses5-dev",
    ]
    apt_install(args, pkgs)
    tmux_tmp = "/tmp/tmux"
    rmtree(tmux_tmp, ignore_errors=True)
    run(f"git clone https://github.com/tmux/tmux.git {tmux_tmp}")

    with chdir(tmux_tmp):
        tag = run("git describe --tags --abbrev=0", capture_output=True).stdout.strip(
            "\n"
        )
        LOG.info("Checking out most recent tmux release: %s", tag)
        run(f"git checkout {tag}")
        run("sh autogen.sh")
        if run("./configure").returncode == 0:
            LOG.debug("tmux build configured. Running `make`")
            run("make")
        else:
            LOG.error("tmux build configure failed!")
            return 1
        LOG.debug("Installing tmux...")
        run("sudo make install")
    LOG.debug("Cleaning up temp directories...")
    rmtree(tmux_tmp, ignore_errors=True)
    return 0


def install_mosh(args) -> None:  # {{{2
    """Download, build, and install mosh."""
    if shutil.which("mosh") and not args.force:
        LOG.warning("mosh already exists. Skipping install!")
        return
    pkgs = [
        "protobuf-compiler",
        "libprotobuf-dev",
        "libutempter-dev",
        "libboost-dev",
        "libio-pty-perl",
        "libssl-dev",
        "pkg-config",
        "autoconf",
    ]
    apt_install(args, pkgs)
    mosh_tmp = "/tmp/mosh"
    rmtree(mosh_tmp, ignore_errors=True)
    run(f"git clone https://github.com/keithw/mosh.git {mosh_tmp}")

    with chdir(mosh_tmp):
        run("sh autogen.sh")
        if run("./configure").returncode == 0:
            LOG.debug("mosh build configured. Running `make`")
            run("make")
        else:
            LOG.error("mosh build configure failed!")
        LOG.debug("Installing mosh...")
        run("sudo make install")
    LOG.debug("Cleaning up temp directories...")
    rmtree(mosh_tmp, ignore_errors=True)


def install_nnn(args) -> int:  # {{{2
    """Download, install and build nnn file manager."""
    if shutil.which("nnn") and not args.force:
        LOG.warning("nnn already exists. Skipping install!")
        return 1
    pkgs = ["pkg-config", "libncursesw5-dev"]
    apt_install(args, pkgs)
    nnn_tmp = "/tmp/nnn"
    rmtree(nnn_tmp, ignore_errors=True)
    run(f"git clone https://github.com/jarun/nnn.git {nnn_tmp}")

    with chdir(nnn_tmp):
        tag = git_latest_tag()
        LOG.info("Checking out most recent nnn release: %s", tag)
        if run(f"git checkout {tag}").returncode == 0:
            run("make")
            LOG.debug("Installing nnn...")
            run("sudo make install")
        else:
            LOG.error("Checkout for latest version of `nnn` failed. Aborting install!")
            LOG.debug("Cleaning up temp directories...")
    rmtree(nnn_tmp, ignore_errors=True)
    return 0


def install_todo(args) -> int:  # {{{2
    """Download and install todo.txt cli."""
    if shutil.which("todo.sh") and not args.force:
        LOG.warning("todo.sh already exists. Skipping install!")
        return 1

    todo_tmp = "/tmp/todo"
    rmtree(todo_tmp, ignore_errors=True)
    run(f"git clone https://github.com/todotxt/todo.txt-cli.git {todo_tmp}")

    with chdir(todo_tmp):
        run("make")
        install = run("sudo make install")
    rmtree(todo_tmp)
    return install.returncode


# Argparse {{{1
def process_args(argv: list):
    """Parse command line arguments and return namespace."""
    parser = argparse.ArgumentParser(
        prog="provision",
        description="provision setup of new machine with standard defaults common to all installs",
    )

    # Top-level options {{{2
    common_parser = argparse.ArgumentParser(add_help=False, parents=[parser])
    common_parser.add_argument("-d", "--debug", action="count", help=argparse.SUPPRESS)
    common_parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        default=False,
        help="force install/action to be completed",
    )
    subparsers = parser.add_subparsers(
        title="commands", description="use -h/--help for any command"
    )

    # All {{{2
    parser_all = subparsers.add_parser("all", help="run all provisioning processes")
    parser_all.set_defaults(func=run_all)

    # Apt {{{2
    parser_apt = subparsers.add_parser(
        "apt",
        help="update apt cache and optionally install packages",
        parents=[common_parser],
        add_help=False,
    )
    # parser_apt.add_argument(
    parser_apt.set_defaults(func=apt_install)

    # Ctags {{{2
    parser_ctags = subparsers.add_parser(
        "ctags",
        help="build and install ctags from source",
        parents=[common_parser],
        add_help=False,
    )
    parser_ctags.set_defaults(func=install_ctags)

    # Fish {{{2
    parser_fish = subparsers.add_parser(
        "fish",
        help="build and install fish shell",
        parents=[common_parser],
        add_help=False,
    )
    parser_fish.set_defaults(func=install_fish)

    # Github {{{2
    parser_github = subparsers.add_parser(
        "github", help="clone github repos", parents=[common_parser], add_help=False
    )
    parser_github.add_argument("dir", type=str, help="destination dir", default="~/git")
    parser_github.set_defaults(func=clone_git_repos)

    parser_github_release = subparsers.add_parser(
        "github-release",
        help="download and install release from github",
        parents=[common_parser],
        add_help=False,
    )
    parser_github_release.add_argument("repo", type=str, help="github repo name")
    parser_github_release.set_defaults(func=github_latest_release)

    # Mosh {{{2
    parser_mosh = subparsers.add_parser(
        "mosh",
        help="build and install mobile shell",
        parents=[common_parser],
        add_help=False,
    )
    parser_mosh.set_defaults(func=install_mosh)

    # nnn {{{2
    parser_nnn = subparsers.add_parser(
        "nnn",
        help="build and install nnn file browser",
        parents=[common_parser],
        add_help=False,
    )
    parser_nnn.set_defaults(func=install_nnn)

    # tmux {{{2
    parser_tmux = subparsers.add_parser(
        "tmux",
        help="build and install terminal multiplexer",
        parents=[common_parser],
        add_help=False,
    )
    parser_tmux.set_defaults(func=install_tmux)

    # todo {{{2
    parser_todo = subparsers.add_parser(
        "todo",
        help="build and install todo.sh cli",
        parents=[common_parser],
        add_help=False,
    )
    parser_todo.set_defaults(func=install_todo)

    return parser.parse_known_args(argv)


# Entry point {{{1
def cli():
    """Command-line entry point."""
    # Get arguments
    try:
        sys.argv[1]
        cli_args = sys.argv[1:]
    except IndexError:
        cli_args = ["-dd", "--help"]
    finally:
        args, extra = process_args(cli_args)

    if args.debug == 1:
        LOG.setLevel(logging.INFO)
    if args.debug == 2:
        LOG.setLevel(logging.DEBUG)

    LOG.info("Argument input: %s", repr(cli_args))
    LOG.info("Argparse output: %s", repr(args))

    if len(extra):
        LOG.info("Argparse extra args: %s", repr(extra))

    # Run function defined in subcommand(s)
    args.func(args)


if __name__ == "__main__":
    cli()
