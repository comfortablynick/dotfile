#!/usr/bin/env python3
"""Main provisioning script."""
import argparse
import errno
import logging
import os
import shutil
import stat
import sys
import warnings
from contextlib import contextmanager
from pathlib import Path
from subprocess import run

from github import Github

# Globals {{{1
logging.basicConfig(
    format="%(levelname)s:%(funcName)s: %(message)s", level=logging.WARNING
)
LOG = logging.getLogger(__name__)
APT_CACHE_UPDATED = False

# Utility Functions {{{1
def mkdir_p(newdir: str) -> None:
    """Make new directory if it doesn't exist.

    Emulates `mkdir -p`
        - if it already exists, silently complete
        - if regular file in the way, raise an exception
        - if parent directories do not exist, make them as well
        From: Pipenv (http://bit.ly/2SLxRwL)
    """
    if os.path.isdir(newdir):
        LOG.debug("%s already exists", newdir)
        pass
    elif os.path.isfile(newdir):
        raise OSError(
            f"a file with the same name as the desired dir, '{newdir}', already exists."
        )

    else:
        head, tail = os.path.split(newdir)
        if head and not os.path.isdir(head):
            mkdir_p(head)
        if tail:
            # Even though we've checked that the directory doesn't exist above, it might exist
            # now if some other process has created it between now and the time we checked it.
            try:
                os.mkdir(newdir)
            except OSError as exn:
                # If we failed because the directory does exist, that's not a problem -
                # that's what we were trying to do anyway. Only re-raise the exception
                # if we failed for some other reason.
                if exn.errno != errno.EEXIST:
                    raise


def set_write_bit(file_name: str) -> None:
    """Make file writable."""
    if isinstance(file_name, str) and not os.path.exists(file_name):
        return
    os.chmod(file_name, stat.S_IWRITE | stat.S_IWUSR | stat.S_IRUSR)
    return


def rmtree(directory: str, ignore_errors=False):
    """Remove directory and contents."""
    LOG.debug("Removing directory tree %s", directory)
    shutil.rmtree(
        directory, ignore_errors=ignore_errors, onerror=handle_remove_readonly
    )


def handle_remove_readonly(func, path: str, exc) -> None:
    """Error handler for shutil.rmtree.

    Windows source repo folders are read-only by default, so this error handler
    attempts to set them as writeable and then proceed with deletion.
    """
    # Check for read-only attribute
    default_warning_message = (
        "Unable to remove file due to permissions restriction: {!r}"
    )
    # split the initial exception out into its type, exception, and traceback
    exc_type, exc_exception, exc_tb = exc
    if is_readonly_path(path):
        # Apply write permission and call original function
        set_write_bit(path)
        try:
            func(path)
        except (OSError, IOError) as e:
            if e.errno in [errno.EACCES, errno.EPERM]:
                warnings.warn(default_warning_message.format(path), ResourceWarning)
                return

    if exc_exception.errno in [errno.EACCES, errno.EPERM]:
        warnings.warn(default_warning_message.format(path), ResourceWarning)
        return

    raise


def is_readonly_path(file_name: str) -> bool:
    """Check if a provided path exists and is readonly.

    Permissions check is `bool(path.stat & stat.S_IREAD)`
    or `not os.access(path, os.W_OK)`
    """
    if os.path.exists(file_name):
        return (os.stat(file_name).st_mode & stat.S_IREAD) or not os.access(
            file_name, os.W_OK
        )

    return False


@contextmanager
def chdir(path: str) -> None:
    """Context manager to change working directories.

    Usage:
        `with chdir(/path/to/execute/cmd/in):`
    """
    if not path:
        return
    prev_cwd = Path.cwd().as_posix()
    if isinstance(path, Path):
        path = path.as_posix()
    os.chdir(str(path))
    try:
        yield
    finally:
        os.chdir(prev_cwd)


# Apt {{{1
def apt_update_cache() -> None:
    """Update apt cache"""
    cmd = ["sudo", "apt", "update"]
    LOG.debug("Command: %s", cmd)
    run(cmd)
    global APT_CACHE_UPDATED
    APT_CACHE_UPDATED = True
    return


def apt_install(pkgs: list) -> None:
    """Update apt cache if necessary and install `pkgs`"""
    if not APT_CACHE_UPDATED:
        # Make sure this is done once per execution
        apt_update_cache()
    cmd = ["sudo", "apt", "install", "-y", *pkgs]
    LOG.debug("Command: %s", cmd)
    run(cmd)
    return


# Git {{{1
def git_clone(repo: str, dest_path: str = None, args: list = ["--recursive"]) -> None:
    """Clone git repo to dest path."""
    if not shutil.which("git"):
        LOG.error("Git not installed!")
        return
    if not repo[0:4] in ("git@", "http"):
        # Assume it's my repo
        repo = f"git@github.com:comfortablynick/{repo}.git"
    if dest_path is not None:
        args.append(os.path.expanduser(dest_path))
    cmd = ["git", "clone", repo, *args]
    LOG.debug("Cmd: %s", " ".join(cmd))
    with chdir(os.path.expanduser("~/git")):
        run(cmd)
    return


def github_token() -> str:
    """Retrieve secret access token from disk."""
    file = os.path.expanduser("~/.github_token")
    token = ""
    try:
        with open(file, "r") as f:
            token = f.read()
    except FileNotFoundError:
        LOG.error("GitHub token file not found: %s. Aborting!", file)
        return None
    else:
        return token.strip("\n")


def clone_git_repos() -> None:
    """Clone repos from GitHub."""
    token = github_token()
    LOG.info("GitHub token found: %s", token)
    if token is None:
        return
    g = Github(token)
    for repo in g.get_user().get_repos():
        root_files = [content.name for content in repo.get_contents(".")]
        if ".provision_ignore" not in root_files:
            git_clone(repo.ssh_url)


# Install/build apps {{{1
def install_tmux() -> None:
    """Download, build, and install tmux."""
    if shutil.which("tmux"):
        LOG.warning("tmux already exists. Skipping install!")
        return
    pkgs = [
        "git",
        "automake",
        "build-essential",
        "pkg-config",
        "libevent-dev",
        "libncurses5-dev",
    ]
    apt_install(pkgs)
    tmux_tmp = "/tmp/tmux"
    rmtree(tmux_tmp, ignore_errors=True)
    run(["git", "clone", "https://github.com/tmux/tmux.git", tmux_tmp])

    with chdir(tmux_tmp):
        run(["git", "checkout", "master"])
        run(["sh", "autogen.sh"])
        if run(["./configure"]).returncode == 0:
            LOG.debug("tmux build configured. Running `make`")
            run(["make"])
        else:
            LOG.error("tmux build configure failed!")
        LOG.debug("Installing tmux...")
        run(["sudo", "make", "install"])
    LOG.debug("Cleaning up temp directories...")
    rmtree(tmux_tmp, ignore_errors=True)


# Parse arguments {{{1
def process_args(argv: list):
    """Parse command line arguments and return namespace."""
    parser = argparse.ArgumentParser(
        prog="provision",
        description="Provision setup of new machine with standard defaults common to all installs",
    )
    parser.add_argument("-d", "--debug", action="count", help=argparse.SUPPRESS)
    parser.add_argument(
        "--all",
        action="store_true",
        default=False,
        help="Run all provisioning processes",
    )
    parser.add_argument(
        "--tmux",
        action="store_true",
        default=False,
        help="Build and install latest version of TMUX",
    )
    parser.add_argument(
        "--git",
        action="store_true",
        default=False,
        help="Clone default git repos to ~/git",
    )
    return parser.parse_args(argv)


# Entry point {{{1
def cli():
    """Command-line entry point."""
    # Get arguments
    try:
        sys.argv[1]
        cli_args = sys.argv[1:]
    except IndexError:
        cli_args = ["-dd", "--git"]
    finally:
        args = process_args(cli_args)

    if args.debug == 1:
        LOG.setLevel(logging.INFO)
    if args.debug == 2:
        LOG.setLevel(logging.DEBUG)

    LOG.info("Argument input: %s", repr(cli_args))
    LOG.info("Argparse output: %s", repr(args))

    if args.all or args.git:
        clone_git_repos()
    if args.all or args.tmux:
        install_tmux()


if __name__ == "__main__":
    cli()
